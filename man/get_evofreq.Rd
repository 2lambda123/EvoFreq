% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EvoFreq_funcs.R
\name{get_evofreq}
\alias{get_evofreq}
\title{get_evofreq

 Collect information to plot frequency dynamics}
\usage{
get_evofreq(size_df, clones, parents, time_pts = NULL,
  attribute_df = NULL, attribute_val_name = NULL,
  clone_id_col_in_att_df = "clone_id", clone_cmap = "rainbow_soft",
  threshold = 0.01, scale_by_sizes_at_time = F, data_type = "size",
  interpolation_steps = 20, interp_method = "monoH.FC",
  fill_gaps_in_size = F, test_links = T, attribute_val_range = NULL,
  add_origin = F, tm_frac = 0.6)
}
\arguments{
\item{size_df}{Dataframe in a wide format, where each row corrsponds to a single clone, and the columns are the sizes of that clone at each timepoint}

\item{clones}{Array containing the clone ids. The index of each clone must correspond to the same index of the row in \code{size_df} that contains the sizes of that clone over time}

\item{parents}{Array containing the ids of the parent of each clone in the \code{clones} array.}

\item{time_pts}{Array containing the name of the timepoints. If NULL, then the name of timepoints will be a sequence from 1 to the number of columns in \code{size_df}.}

\item{attribute_df}{Optional dataframe containing attributes for each clone that can be used to determine the color of each clone in the plot. This can include a column of custom colors to use \code{attribute_val_name}.}

\item{attribute_val_name}{String defining which column in \code{attribute_df} will be used to color each clone. If attribute column values are a hex code in this column, these colors will be used instead of \code{clone_cmap}.}

\item{clone_id_col_in_att_df}{Name of the column in attribute_df that contains the clone IDs}

\item{clone_cmap}{Colormap to use for the clones. For a list of available colormaps, see \code{\link[colormap]{colormaps}}.}

\item{threshold}{The minimum frequency of clones to be plotted. Clones with with a frequency below this value will not be plotted}

\item{scale_by_sizes_at_time}{Boolean defining whether or not the plot should represent the size or frequency of each clone at each timepoint. If TRUE, the sizes are scaled by the maximum size at each timepoint, and the plot thus represents the clonal frequencies at each timepoint. If FALSE, the sizes are scaled using the maximum size in \code{size_df}, thus reflecting relative population sizes}

\item{data_type}{String defining what kind of information is in size_df. If "size", then the values in \code{size_df} are the population sizes. If "mutation", the values are the frequencies, between 0 and 1, of each mutation in the population over time}

\item{interpolation_steps}{Integer defining the number of knots to use in the spline interpolation used to fill in the gaps between observed population sizes. For sparse data, this smooths out the curves in the plot. Not recommended if the data is dense, as this is slow and may not have noticable effects}

\item{interp_method}{String identifying the interpolation method to use. Either "bezier", or a method used by \code{\link[stats]{splinefun}}}

\item{fill_gaps_in_size}{Boolean defining whether or not missing sizes should be filled in}

\item{test_links}{Make sure clone does not have the same id as it's parent. If true, it can cause infinite recursion.}

\item{attribute_val_range}{Range of values for the attribute to color by. If NULL, then range is determined from the attribute data}

\item{add_origin}{Boolean defining whether or not to add origin positions to founder clones, even if not present in the data. Best for sparse observed data}

\item{tm_frac}{Value between 0 and 1 that determines where the maximum growth rate is in the inferred origin sizes. Lower values result in earlier maximum growth}
}
\value{
Formatted dataframe called a "freq_frame" containing the information needed to plot the frequency dynamics over time.
}
\description{
get_evofreq

 Collect information to plot frequency dynamics
}

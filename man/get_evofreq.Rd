% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EvoFreq_funcs.R
\name{get_evofreq}
\alias{get_evofreq}
\title{get_evofreq

 Collect information to plot frequency dynamics}
\usage{
get_evofreq(size_df, clones, parents, time_pts = NULL,
  attribute_df = NULL, attribute_val_name = NULL,
  clone_id_col_in_att_df = "clone_id", clone_cmap = "rainbow_soft",
  threshold = 0.01, scale_by_sizes_at_time = F, data_type = "size",
  interpolation_steps = 20, interp_method = "monoH.FC",
  fill_gaps_in_size = F, test_links = T, attribute_val_range = NULL,
  add_origin = F, tm_frac = 0.6)
}
\arguments{
\item{size_df}{Dataframe in a wide format, where each row corrsponds to a single clone, and the columns are the sizes of that clone at each timepoint}

\item{clones}{Array containing the clone ids. The index of each clone must correspond to the same index of the row in \code{size_df} that contains the sizes of that clone over time}

\item{parents}{Array containing the ids of the parent of each clone in the \code{clones} array.}

\item{time_pts}{Array containing the name of the timepoints. If NULL, then the name of timepoints will be a sequence from 1 to the number of columns in \code{size_df}.}

\item{attribute_df}{Optional dataframe containing attributes for each clone that can be used to determine the color of each clone in the plot. This can include a column of custom colors to use \code{attribute_val_name}.}

\item{attribute_val_name}{String defining which column in \code{attribute_df} will be used to color each clone. If attribute column values are a hex code in this column, these colors will be used instead of \code{clone_cmap}.}

\item{clone_id_col_in_att_df}{Name of the column in attribute_df that contains the clone IDs}

\item{clone_cmap}{Colormap to use for the clones. For a list of available colormaps, see \code{\link[colormap]{colormaps}}.}

\item{threshold}{The minimum frequency of clones to be plotted. Clones with with a frequency below this value will not be plotted}

\item{scale_by_sizes_at_time}{Boolean defining whether or not the plot should represent the size or frequency of each clone at each timepoint. If TRUE, the sizes are scaled by the maximum size at each timepoint, and the plot thus represents the clonal frequencies at each timepoint. If FALSE, the sizes are scaled using the maximum size in \code{size_df}, thus reflecting relative population sizes}

\item{data_type}{String defining what kind of information is in size_df. If "size", then the values in \code{size_df} are the population sizes. If "mutation", the values are the frequencies, between 0 and 1, of each mutation in the population over time}

\item{interpolation_steps}{Integer defining the number of knots to use in the spline interpolation used to fill in the gaps between observed population sizes. For sparse data, this smooths out the curves in the plot. Not recommended if the data is dense, as this is slow and may not have noticable effects}

\item{interp_method}{String identifying the interpolation method to use. Either "bezier", or a method used by \code{\link[stats]{splinefun}}}

\item{fill_gaps_in_size}{Boolean defining whether or not missing sizes should be filled in}

\item{test_links}{Make sure clone does not have the same id as it's parent. If true, it can cause infinite recursion.}

\item{attribute_val_range}{Range of values for the attribute to color by. If NULL, then range is determined from the attribute data}

\item{add_origin}{Boolean defining whether or not to add origin positions to founder clones, even if not present in the data. Best for sparse observed data}

\item{tm_frac}{Value between 0 and 1 that determines where the maximum growth rate is in the inferred origin sizes. Lower values result in earlier maximum growth}
}
\value{
Formatted dataframe called a "freq_frame" containing the information needed to plot the frequency dynamics over time.
}
\description{
get_evofreq

 Collect information to plot frequency dynamics
}
\examples{
\donttest{
data("example.easy.wide")
### Split dataframe into clone info and size info using fact timepoint column names can be converted to numeric values
time_col_idx <- suppressWarnings(which(! is.na(as.numeric(colnames(example.easy.wide)))))
attribute_col_idx <-suppressWarnings(which(is.na(as.numeric(colnames(example.easy.wide)))))

attribute_df <- example.easy.wide[, attribute_col_idx]
size_df <- example.easy.wide[, time_col_idx]
parents <- example.easy.wide$parents
clones <- example.easy.wide$clones

### Default is to plot size
freq_frame <- get_evofreq(size_df, clones, parents)
evo_p_by_size <- plot_evofreq(freq_frame)

### Can also plot frequency by setting scale_by_sizes_at_time = TRUE.
freq_frame <- get_evofreq(size_df, clones, parents, scale_by_sizes_at_time = TRUE)
evo_p_by_freq <- plot_evofreq(freq_frame)

### Default is to mildly smooth corners, but this can be turned by setting interpolation_steps = 0
freq_frame <- get_evofreq(size_df, clones, parents, interpolation_steps = 0)
raw_evo_p <- plot_evofreq(freq_frame)

### Several other methods to smooth corners, including using Bezier curves. However, Bezier curves dont represent the data as accurately as the methods that use splinefun, i.e. c("fmm", "periodic", "natural", "monoH.FC", "hyman")
freq_frame <- get_evofreq(size_df, clones, parents, interp_method = "bezier")
bez_evo_p <- plot_evofreq(freq_frame)

### Data can also be provided as mutaiton frequencies by setting data_type = "mutation"
mutation_count_df <- get_mutation_df(size_df, clones, parents)
freq_frame <- get_evofreq(mutation_count_df, clones, parents, data_type = "mutation")
evo_p_from_mutation <- plot_evofreq(freq_frame)

### Input needs to be in wide format, but can convert long format data to wide format using \\code{\\link{long_to_wide_freqframe}}
wide_df_info <- long_to_wide_freqframe(long_pop_sizes_df = example.easy.long.sizes, time_col_name = "Time", clone_col_name = "clone", parent_col_name = "parent", size_col_name = "Size", edges_df = example.easy.long.edges)
clones_from_long <- wide_df_info$clones
parents_from_long <- wide_df_info$parents
size_df_from_long <- wide_df_info$wide_size_df
freq_frame <- get_evofreq(size_df_from_long, clones_from_long, parents_from_long)
evo_p_from_long <- plot_evofreq(freq_frame)

### Can also color each genotype by an attribute. This can be set when getting the frequency dynamics, or by updating the color later using \\code{\\link{update_colors}}
data("example.easy.wide.with.attributes")
### Split dataframe into clone info and size info using fact timepoint column names can be converted to numeric values
time_col_idx <- suppressWarnings(which(! is.na(as.numeric(colnames(example.easy.wide.with.attributes)))))
attribute_col_idx <- suppressWarnings(which(is.na(as.numeric(colnames(example.easy.wide.with.attributes)))))
attribute_df <- example.easy.wide.with.attributes[, attribute_col_idx]
attr_size_df <- example.easy.wide.with.attributes[, time_col_idx]
attr_parents <- example.easy.wide.with.attributes$parent
attr_clones <- example.easy.wide.with.attributes$clone
clone_id_col <- "clone"
### Can set color using attributes. Default colormap is viridis, but can be changed to any colormap available in the colormaps package
freq_frame <- get_evofreq(attr_size_df, attr_clones, attr_parents, attribute_df = attribute_df, attribute_val_name = "fitness", clone_id_col_in_att_df = clone_id_col, clone_cmap="magma")
fitness_evo_p <- plot_evofreq(freq_frame)
}
}
